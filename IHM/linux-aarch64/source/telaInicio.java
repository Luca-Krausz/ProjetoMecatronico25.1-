/* autogenerated by Processing revision 1297 on 2025-04-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class telaInicio extends PApplet {

// UI elements
Button  botao_tutorial, modo_manual, modo_automatico, modo_hist;

 // Definindo as características dos botões de "modo"

public void setupTelaInicio() {
   if (inicio_config == false) {
   inicio_config = true;
   }
   
   botao_tutorial =  new Button(true, 80, 350, 120, 40, "Tutorial", brancoBege, azulEscuro);    // (square?, x, y, w, h, label, bgColor, textcolor)
   modo_manual =     new Button(true, 692, 250, 200, 40, "Manual", azulEscuro, branco);         // (square?, x, y, w, h, label, bgColor, textcolor)
   modo_automatico = new Button(true, 692, 305, 200, 40, "Automático", azulEscuro, branco);     // (square?, x, y, w, h, label, bgColor, textcolor)
   modo_hist =       new Button(true, 692, 360, 200, 40, "Histórico", azulEscuro, branco);      // (square?, x, y, w, h, label, bgColor, textcolor)
  
}


public void desenhaTelaInicio() {
  // Left side (white background)
  fill(branco);
  rect(0, 0, 560, janelaAltura);

  textSize(fontTitulo);
  fill(azulEscuro);
  textAlign(LEFT, TOP);
  text("Bem vindo!", 80, 255);

  textSize(fontSubtitulo);
  fill(cinzaEscuro);
  text("Projeto Mecatrônico", 80, 305);

  // Right side (beige background)
  fill(brancoBege);
  rect(560, 0, 464, janelaAltura);

  // Title on the right side
  textSize(28);
  fill(azulEscuro);
  textAlign(CENTER, TOP);
  text("Escolha o modo\nde operação", 560 + 464/2, 150);
  
  // Draw the buttons
  botao_tutorial.draw();
  modo_manual.draw();
  modo_automatico.draw();
  modo_hist.draw();

}

//----------------------------------------------------------------------------------------
//                           'Mouse pressed' for tela inicio
//----------------------------------------------------------------------------------------
public void mousePressedInicio() {
  // Tutorial
  if (botao_tutorial.isMouseOver()) {
    botao_tutorial.isPressed = true;
    
  }

  // Manual
  else if (modo_manual.isMouseOver()) {
    modo_manual.isPressed = true;
    
  }

  // Automático
  else if (modo_automatico.isMouseOver()) {
    modo_automatico.isPressed = true;
    
  }

  // Histórico
  else if (modo_hist.isMouseOver()) {
    modo_hist.isPressed = true;
    
  }
}

//----------------------------------------------------------------------------------------
//                           'Mouse released' for tela inicio
//----------------------------------------------------------------------------------------

public void mouseReleasedInicio() {
  if (botao_tutorial.isPressed) {
     botao_tutorial.isPressed = false;
     
     println("Botão TUTORIAL clicado!");
  }
  
  else if (modo_manual.isPressed) {
    modo_manual.isPressed = false;
    
    setupReferenciar();
    telaInicio      = false;
    telaReferenciar = true; 
  }
  
  else if (modo_automatico.isPressed) {
    modo_automatico.isPressed = false; 
    
    println("Botão AUTOMÁTICO clicado!");
  }
  
  else if(modo_hist.isPressed) {
   modo_hist.isPressed = false;
   
   println("Botão HISTÓRICO clicado!");
  }
  
  
  
  
}
// Globals.pde


// ------------------ GLOBAL VARIABLES ------------------

// Fonts
PFont fonteAtual;
PFont fonte1, fonte2, fonte3, fonte4;

// Colors
int azulEscuro  = color(12, 78, 140);
int branco      = color(255, 255, 255);
int brancoBege  = color(243, 243, 243);
int azulClaro   = color(0, 132, 255);
int cinzaEscuro = color(105, 105, 105);
int cinzaClaro  = color(211, 211, 211);
int cinzaMedio  = color(169, 169, 169);
int verdeBotao = color(0x00, 0xAA, 0x41);

// Window size
int janelaLargura = 1024;
int janelaAltura  = 600;

// Font sizes
int fontTitulo    = 50;
int fontSubtitulo = 17;
int fontBotao     = 20;

// Booleans of buttons
boolean telaInicio         = true;
boolean telaReferenciar    = false;
boolean telaPipetagem      = false;
boolean telaPontosColeta   = false;
boolean telaPontosDispensa = false;
boolean telaReferenciarI2C = false;
boolean pressedPontoColeta = false;
boolean pressedPontoDispensa = false;
boolean pressedIniciarPipetagem = false;
boolean pressedPausa = false;
boolean pressedParar = false;
boolean pressedPontosTotaisColeta = false;

// Variaveis globais
int pontosColeta   = 0;
int pontosDispensa = 0;
int tempoRestante  = 50;
boolean pipetagemAtiva   = false;
boolean pipetagemPausada = false;
boolean inicio_config = false;
int movSpeed       = 1;  // 1mm, 10mm, 30mm

int maxX = 665;
int minX = 0;
int maxY = 560;
int minY = 0;
int maxZ = 100;
int minZ = 0;

// Shapes for the directional pad
PShape dirPad;
PShape[] segments = new PShape[4];

// ArrayLists, etc.
ArrayList<String>  listaPontosManual        = new ArrayList<String>();
ArrayList<Boolean> listaPontosManualChecked = new ArrayList<Boolean>();

// Images / Shapes
PImage homeXY, homeZ, logo, trash, editpen, addicon, backIcon;
PShape iconeXY;

// Botão voltar 
Button backButton;

// ------------------ SETTINGS & SETUP ------------------
public void settings() {
  size(janelaLargura, janelaAltura, P2D);
}

public void setup() {
  // Load fonts
  fonte1 = createFont("InstrumentSans-Bold.ttf",    fontTitulo);
  fonte2 = createFont("InstrumentSans-Italic.ttf",  fontTitulo);
  fonte3 = createFont("InstrumentSans-SemiBold.ttf",fontTitulo);
  fonte4 = createFont("InstrumentSans-Regular.ttf", fontTitulo);
  fonteAtual = fonte1;
  textFont(fonteAtual);

  // Load images, shapes
  logo = loadImage("logo.png");
  if (logo != null) {
    logo.resize(150, 0);
  }
  iconeXY = loadShape("XY.svg");
  homeXY = loadImage("homeXY.png");
  homeZ = loadImage("homeZ.png");
  
  trash = loadImage("trash.png");
  trash.resize(50,0);
  
  editpen = loadImage("editpen.png");
  editpen.resize(50,0);
  
  addicon = loadImage("addicon.png");
  addicon.resize(50,0);
  
  backIcon = loadImage("backIcon.png");
  backIcon.resize(25,0);
  
  // Botão voltar
  backButton = new Button(false, width - 30, 35, 40, 40, backIcon, azulEscuro); // (square?, x, y, w, h, icon, bgColor)
    
  // Any array initializations
  inicializaListaPontosManual();

  noStroke();
}

// ------------------ MAIN DRAW ------------------
public void draw() {
  background(branco);

  // Decide qual tela mostrar
  if (telaInicio) {
    if (!inicio_config){
     setupTelaInicio(); 
    }
    desenhaTelaInicio();
  }
  else if (telaReferenciar) {
    desenhaTelaReferenciar();
  }
  else if (telaReferenciarI2C) {
    desenhaRefI2C();
  }
  else if (telaPipetagem) {
    desenhaTelaPipetagem();
    
    // Example: pipetagem countdown
    if (pipetagemAtiva && !pipetagemPausada && tempoRestante > 0) {
      if (frameCount % 60 == 0) {
        tempoRestante--;
      }
    }
  }
  else if (telaPontosDispensa) {
    desenhaTelaPontosDispensa();
  }
  else {
    // fallback
    desenhaTelaPipetagem();
  }
}

// ------------------ MAIN MOUSEPRESSED ------------------
public void mousePressed() {
  
  if (telaInicio) {
    mousePressedInicio();
  }
  else if (telaReferenciar) {
    mousePressedReferenciar();
  }
  else if (telaReferenciarI2C) {
    mousePressedRefI2C();
  }
  else if (telaPipetagem) {
    mousePressedPipetagem();
  }
  else if (telaPontosDispensa) {
    mousePressedTelaMovimentacaoManual();
  }
}

// ------------------ MAIN MOUSERELEASED ------------------
// Complement the press & release approach:
public void mouseReleased() {
  // Colocar a tela para conseguir 
  if (telaPontosDispensa) {
    mouseReleasedTelaMovimentacaoManual();
  }
  else if (telaPipetagem) {
     mouseReleasedPipetagem(); 
  }
  else if (telaInicio) {
     mouseReleasedInicio();
  }
  else if (telaReferenciar) {
      mouseReleasedReferenciar();
  }
  else if (telaReferenciarI2C) {
     mouseReleasedRefI2C();
  }
}
//----------------------------------------------------------------------------------------
//                                      FUNÇÕES GLOBAIS 
//----------------------------------------------------------------------------------------
// 1. Simple button
public void desenhaBotao(float x, float y, float w, float h,
                  String rotulo, int corFundo, int corTexto) {
  fill(corFundo);
  rect(x, y, w, h, 8);
  fill(corTexto);
  textSize(fontBotao);
  textAlign(CENTER, CENTER);
  text(rotulo, x + w/2, y + h/2);
}

// 2. Example initialization for manual points
public void inicializaListaPontosManual() {
  listaPontosManual.clear();
  listaPontosManual.add("Ponto 01 - 3ml");
  listaPontosManual.add("Ponto 02 - 5ml");

  listaPontosManualChecked.clear();
  listaPontosManualChecked.add(true);
  listaPontosManualChecked.add(false);
}

// 3. 'Voltar' round button
public void desenhaBotaoVoltar(float cx, float cy, float diameter) {
  fill(azulEscuro);
  noStroke();
  ellipse(cx, cy, diameter, diameter);
  fill(branco);
  float arrowSize = 8;
  triangle(cx - arrowSize/2, cy,
           cx + arrowSize/2, cy - arrowSize,
           cx + arrowSize/2, cy + arrowSize);
}

// 4. Classe "Botao precisao" 
class SegmentedButton {
  float x, y, w, h;
  String[] labels;
  int[] bgColors;
  int textColor;
  int selectedIndex = 0;  // which segment is currently active
  int pressedIndex  = -1; // which segment is being pressed, if any
  
  SegmentedButton(float x, float y, float w, float h, 
                  String[] labels, int[] bgColors, int textColor) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.labels = labels;
    this.bgColors = bgColors;
    this.textColor = textColor;
  }
  
  public void draw() {
    float segmentWidth = w / labels.length;
    
    // Outer rectangle as a border (optional style)
    stroke(azulEscuro);
    strokeWeight(2);
    fill(azulEscuro);
    rect(x, y, w, h, h/2);  // Using h/2 to get a pill shape
    noStroke();
    
    // Draw each segment
    for (int i = 0; i < labels.length; i++) {
      int currentBg = azulEscuro; // default
      if (i == selectedIndex && i < bgColors.length) {
        currentBg = bgColors[i];
      }
      // Darken if pressed
      if (i == pressedIndex) {
        currentBg = lerpColor(currentBg, color(0), 0.2f);
      }
      
      fill(currentBg);
      float segX = x + i * segmentWidth;
      
      // Round corners depending on position
      if (labels.length == 1) {
        // Only one segment
        rect(segX, y, segmentWidth, h, h/2);
      } 
      else if (i == 0) {
        // Left end
        rect(segX, y, segmentWidth, h, h/2, 0, 0, h/2);
      } 
      else if (i == labels.length - 1) {
        // Right end
        rect(segX, y, segmentWidth, h, 0, h/2, h/2, 0);
      } 
      else {
        // Middle
        rect(segX, y, segmentWidth, h);
      }
      
      // Segment label
      fill(branco);
      textSize(fontBotao);
      textAlign(CENTER, CENTER);
      text(labels[i], segX + segmentWidth/2, y + h/2);
    }
  }
  
  // Check which segment (if any) was clicked
  public int getClickedSegment() {
    float segmentWidth = w / labels.length;
    if (mouseX >= x && mouseX <= x + w &&
        mouseY >= y && mouseY <= y + h) {
      // which segment?
      int index = PApplet.parseInt((mouseX - x) / segmentWidth);
      // clamp it just in case
      return constrain(index, 0, labels.length - 1);
    }
    return -1;
  }
  
  // Called from mousePressed (outside this class)
  public void mousePressed() {
    pressedIndex = getClickedSegment();
  }
  
  // Called from mouseReleased
  public void mouseReleased() {
    int clicked = getClickedSegment();
    if (clicked == pressedIndex && clicked >= 0) {
      // Update selected index
      selectedIndex = clicked;
      
      // Convert label to an integer.
      // e.g. '1mm', '10mm', '30mm'.
      // This removes all non-digits so spaces or extra chars don't break it.
      String numericPart = labels[selectedIndex].replaceAll("\\D+", "");
      if (numericPart.length() > 0) {
        movSpeed = Integer.parseInt(numericPart);
      }
      println("SegmentedButton -> selectedIndex=" + selectedIndex 
              + ", label=" + labels[selectedIndex] + ", movSpeed=" + movSpeed);
    }
    pressedIndex = -1;
  }
}

// 5. Classe botao
class Button {
  float x, y, w, h;
  String label;
  int bgColor, textColor;
  PImage icon; // optional image for the button
  
  boolean isSelected = false; // toggles color if 'active'
  boolean isPressed  = false; // darkens color while pressed
  
  boolean square;
  
  // Constructor for text-based buttons
  Button(boolean square, float x, float y, float w, float h,  // (square?, x, y, w, h, label, bgColor, textcolor)
         String label, int bgColor, int textColor) {
    this.x = x; 
    this.y = y;
    this.w = w;
    this.h = h;
    this.label = label;
    this.bgColor = bgColor;
    this.textColor = textColor;
    this.square = square;
    this.icon = null; // no icon by default
  }
  
  // Constructor for icon-based buttons
  Button(boolean square, float x, float y, float w, float h, // (square?, x, y, w, h, icon, bgColor)
         PImage icon, int bgColor) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.icon = icon;
    this.bgColor = bgColor;
    this.textColor = color(255); // default text color (unused if icon is present)
    this.square = square;
    this.label = "";
  }
  
public void draw() {
  int currentBg = bgColor;
  if (isPressed) {
    currentBg = cinzaEscuro; // darken if pressed
  }
  else if (isSelected) {
    currentBg = azulClaro;  // highlight if selected
  }
  
  fill(currentBg);
  if (square) {
    rect(x, y, w, h, 8);
    
    // Centraliza icone para o retangulo
    if (icon != null) {
      float iconX = x + (w - icon.width) / 2;
      float iconY = y + (h - icon.height) / 2;
      image(icon, iconX, iconY);
    } else {
      fill(textColor);
      textSize(fontBotao);
      textAlign(CENTER, CENTER);
      text(label, x + w/2, y + h/2);
    }
  } else {
    // Centraliza icone em elipses
    ellipse(x, y, w, h);
    
    if (icon != null) {
      float iconX = x - icon.width / 2;
      float iconY = y - icon.height / 2;
      image(icon, iconX, iconY);
    } else {
      fill(textColor);
      textSize(fontBotao);
      textAlign(CENTER, CENTER);
      text(label, x, y);
    }
  }
}
  
public boolean isMouseOver() {
  if (square) {
    return (mouseX >= x && mouseX <= x + w && 
            mouseY >= y && mouseY <= y + h);
  } else {
    float dx = mouseX - x;
    float dy = mouseY - y;
    
    float a = w/2;
    float b = h/2;
    return ((dx*dx)/(a*a) + (dy*dy)/(b*b)) <= 1;
    }
  }
}
// -----------------------------------------------------------------------------
//  TELA CONTROLE PIPETAGEM
// -----------------------------------------------------------------------------

// UI elements
Button AddColeta, AddDispensa, iniciaPip, pausaPip, pararPip;

public void setupTelaPipetagem() {
  // "+ Ponto de coleta"
  //color corMaisPonto = (pipetagemAtiva) ? cinzaMedio : azulClaro;
  AddColeta = new Button(true, 80, 260, 140, 80, "+ Ponto de \ncoleta", azulClaro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  AddDispensa = new Button(true, 370, 350, 140, 80, "+ Ponto de \ndispensa", azulClaro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  
  iniciaPip = new Button(true, 600, 380, 350, 120, "INICIAR \nPIPETAGEM", azulEscuro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  desenhaTriangulo(870, 440, 40, branco);
  
  pausaPip = new Button(true, 620, 100, 140, 150, "|| \nPausa \npipetagem", cinzaClaro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  pararPip = new Button(true, 790, 100, 140, 150, "Parar \npipetagem", cinzaClaro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  
}


public void desenhaTelaPipetagem() {
  // Ex: exibe um logo no topo direito, se existente
  if (logo != null) {
    image(logo, width - logo.width - -30, -30);
  }

  // Título
  fill(0);
  textSize(fontTitulo - 15);
  textAlign(LEFT, CENTER);
  text("Projeto Mecatrônico\nPipetadora automática", 80, 140);

  // Modo atual
  textSize(fontSubtitulo);
  fill(cinzaEscuro);
  text("Modo atual:", 80, 200);
  fill(0);
  text("manual", 180, 200);

  // Desenha botao
  AddColeta.draw();
  AddDispensa.draw();
  iniciaPip.draw();
  pausaPip.draw();
  pararPip.draw();

  // Seção total de coleta
  desenhaSecaoPontos(250, 260, "Pontos totais de \ncoleta", pontosColeta);

  // "+ Ponto de dispensa"
  desenhaSecaoPontos(80, 350, "Pontos totais de \ndispensa", pontosDispensa);

  // Caixa para tempo restante
  fill(branco);
  stroke(azulEscuro);
  strokeWeight(3);
  rect(600, 280, 350, 80, 20);
  noStroke();

  fill(azulEscuro);
  textSize(fontSubtitulo + 5);
  text("Tempo restante \npara pipetagem", 700, 320);

  fill(azulEscuro);
  textSize(fontSubtitulo);
  text(tempoRestante + " s", 900, 320);

}

//----------------------------------------------------------------------------------------
//                           'Mouse pressed' for tela pipetagem 
//----------------------------------------------------------------------------------------
public void mousePressedPipetagem() {
  if (AddColeta.isMouseOver()) {
    AddColeta.isPressed = true;
    return;
  }
  else if (AddDispensa.isMouseOver()) {
    AddDispensa.isPressed = true;
    return;
  }
  else if (iniciaPip.isMouseOver()) {
    iniciaPip.isPressed = true;
    return;
  }
  else if (pausaPip.isMouseOver() && pipetagemAtiva) {
    pausaPip.isPressed = true;
    return;
  }
  else if (pararPip.isMouseOver() && (pipetagemAtiva || pipetagemPausada)) {
    pararPip.isPressed = true;
    return;
  }
  else if (mouseX > 250 && mouseX < 510 && mouseY > 260 && mouseY < 340) {
    pressedPontosTotaisColeta = true;
  }
}

//----------------------------------------------------------------------------------------
//                           'Mouse released' for tela pipetagem 
//----------------------------------------------------------------------------------------
public void mouseReleasedPipetagem() {
  if (AddColeta.isPressed) {
    AddColeta.isPressed = false;
    
    //setupTelaPontosColeta(); //Inicializa o setup da prox. tela 
    
    // Mudança de telas
    //telaPipetagem = false;
    //telaPontosColeta = true;
  }
  
  else if(AddDispensa.isPressed){
    AddDispensa.isPressed = false;
    
    
    // Mudança de telas
    setupTelaPontosDispensa();
    telaPipetagem = false;
    telaPontosDispensa = true;
  }
  
  else if(iniciaPip.isPressed) {
     pipetagemAtiva = true;
     pipetagemPausada = false;
     
     pararPip = new Button(true, 790, 100, 140, 150, "Parar \npipetagem", azulEscuro, branco);
     pausaPip = new Button(true, 620, 100, 140, 150, "|| \nPausa \npipetagem", azulEscuro, branco);
     iniciaPip = new Button(true, 600, 380, 350, 120, "INICIAR \nPIPETAGEM", cinzaClaro, branco);  
     
     gerarListaFormatoFinal();
     println(gerarStringFormatoFinal());
     println("Função iniciarPipetagem() executada.");
  }
  
  else if(pausaPip.isPressed){
      pipetagemAtiva = false;
      pipetagemPausada = true;
     
     pararPip = new Button(true, 790, 100, 140, 150, "Parar \npipetagem", azulEscuro, branco);
     pausaPip = new Button(true, 620, 100, 140, 150, "|| \nPausa \npipetagem", cinzaClaro, branco);
     iniciaPip = new Button(true, 600, 380, 350, 120, "INICIAR \nPIPETAGEM", azulEscuro, branco);       

  }
  
  else if (pararPip.isPressed){
    pararPip.isPressed = false;
    
    pipetagemAtiva = false;
    pipetagemPausada = false;
    tempoRestante = 50;
    
    pararPip = new Button(true, 790, 100, 140, 150, "Parar \npipetagem", cinzaClaro, branco);
    pausaPip = new Button(true, 620, 100, 140, 150, "|| \nPausa \npipetagem", cinzaClaro, branco);
    iniciaPip = new Button(true, 600, 380, 350, 120, "INICIAR \nPIPETAGEM", azulEscuro, branco);     
    println("Parar pipetadora");
  }
  
}
//----------------------------------------------------------------------------------------
//                                 Funções de controle
//----------------------------------------------------------------------------------------
public void iniciarPipetagem() {
  pipetagemAtiva   = true;
  pipetagemPausada = false;
  
}

public void pausarPipetagem() {
  pipetagemPausada = !pipetagemPausada;
  println("Função pausarPipetagem() executada.");
}

public void pararPipetagem() {
  pipetagemAtiva   = false;
  pipetagemPausada = false;
  tempoRestante    = 50;
  println("Função pararPipetagem() executada.");
}

// For convenience, an example "desenhaSecaoPontos()" from your code:
public void desenhaSecaoPontos(float x, float y, String titulo, int quantidade) {
  fill(brancoBege);
  rect(x, y, 260, 80, 12);
  fill(cinzaEscuro);
  textSize(20);
  textAlign(LEFT, CENTER);
  text(titulo, x + 15, y + 40);

  fill(azulClaro);
  ellipse(x + 220, y + 40, 40, 40);
  fill(branco);
  textAlign(CENTER, CENTER);
  textSize(20);
  text(quantidade, x + 220, y + 40);
}

// And a small helper for the triangle (the "play" icon):
public void desenhaTriangulo(float x, float y, float tamanho, int cor) {
  fill(cor);
  noStroke();
  triangle(x, y - tamanho/2, x, y + tamanho/2, x + tamanho, y);
}
// Original global variables
int[] coordenadas = {0, 0, 0};    // X, Y, Z coordinates
ArrayList<PontoDispensa> listaPontos = new ArrayList<PontoDispensa>();

boolean scrollingUp    = false;
boolean scrollingDown  = false;
int scrollOffset       = 0;
int maxVisiblePoints   = 5;
int selectedPoint      = -1;

// Global lock states
boolean xyLocked = false;
boolean zLocked  = false;

// UI elements
Button addButton, deleteButton, editButton, lockXYButton, lockZButton, z_plus, z_minus, z_home, xy_home;
SegmentedButton precisionSelector;  // Using only the SegmentedButton for precision
String[] precisionLabels = {"1mm", "10mm", "30mm"};  // Global precision labels

// Scroll arrow buttons
Button scrollUpButton, scrollDownButton;
boolean hasItemsAbove = false;
boolean hasItemsBelow = false;


// -----------------------------------------------------------------------------
// Classes for handling points & buttons
// -----------------------------------------------------------------------------
class PontoDispensa {
  String nome;
  int volume;
  int[] coords = {0, 0, 0};
  int[] coordsColeta = {0, 0, 0}; // Collection coords: x_coleta, y_coleta, z_coleta
  boolean selected = false;

  // Added xc, yc, zc parameters for collection coordinates
  PontoDispensa(String n, int v, int x, int y, int z, int xc, int yc, int zc) {
    nome       = n;
    volume     = v;
    coords[0]  = x;
    coords[1]  = y;
    coords[2]  = z;

    coordsColeta[0] = xc;
    coordsColeta[1] = yc;
    coordsColeta[2] = zc;
  }

  // Original toString method
  public String toString() {
    // e.g. 'Ponto 01 - 3ml' plus coordinates
    return nome + " - " + volume + "ml";
  }
}

// -----------------------------------------------------------------------------
// Build the directional pad (dirPad + segments are from Globals.pde).
// -----------------------------------------------------------------------------
// Original function - No changes
public void botao_direcional(float x, float y, float raioMaior, float raioMenor) {
  dirPad = createShape(GROUP);

  for (int i = 0; i < 4; i++) {
    segments[i] = createShape();
    segments[i].beginShape();
    segments[i].fill(azulEscuro);
    segments[i].stroke(255);
    segments[i].strokeWeight(10); // Original stroke weight

    float alpha_inicial = PI/4 + i * PI/2;
    float alpha_final   = 3*PI/4 + i * PI/2;

    for (float a = alpha_inicial; a <= alpha_final; a += 0.01f) {
      float sx = x + cos(a)*raioMenor;
      float sy = y + sin(a)*raioMenor;
      segments[i].vertex(sx, sy);
    }
    for (float a = alpha_final; a >= alpha_inicial; a -= 0.01f) {
      float sx = x + cos(a)*raioMaior;
      float sy = y + sin(a)*raioMaior;
      segments[i].vertex(sx, sy);
    }

    segments[i].endShape(CLOSE);
    dirPad.addChild(segments[i]);
  }
}

// -----------------------------------------------------------------------------
// The setup function for 'PontosDispensa'
// -----------------------------------------------------------------------------
// Original function - No changes
public void setupTelaPontosDispensa() {
  // Create UI elements (positions approximate)
  addButton    = new Button(true, width - 327, height - 180, 80, 80, addicon,  azulEscuro); // (square?, x, y, w, h, icon, bgColor)
  editButton   = new Button(true, width - 227, height - 180, 80, 80, editpen,  azulEscuro); // (square?, x, y, w, h, icon, bgColor)
  deleteButton = new Button(true, width -  127, height - 180, 80, 80, trash,  azulEscuro); // (square?, x, y, w, h, icon, bgColor)

  // Lock buttons
  lockXYButton = new Button(true, 120, height - 120, 120, 40, "Lock XY", cinzaMedio, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  lockZButton  = new Button(true, 260, height - 120, 120, 40, "Lock Z",  cinzaMedio, branco); // (square?, x, y, w, h, label, bgColor, textcolor)

  scrollUpButton   = new Button(true, width - 100, height/2 - 150, 40, 40, "↑", azulEscuro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  scrollDownButton = new Button(true, width - 100, height/2 + 10, 40, 40, "↓", azulEscuro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)

  // Initialize precision selector using the global precisionLabels array
  int[] precisionColors = {verdeBotao, verdeBotao, verdeBotao};
  precisionSelector = new SegmentedButton(100, 30, 300, 40, precisionLabels, precisionColors, azulEscuro);
  precisionSelector.selectedIndex = 0;

  // Draw the direction pad (Buttons for XY axis)
  botao_direcional(250, 300, 150, 80);

  // Draw the Buttons for the Z axis
  z_plus = new Button(true, 500, height - 490, 95, 95, "Z+", azulEscuro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  z_minus = new Button(true, 500, height - 192, 95, 95, "Z-", azulEscuro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  z_home = new Button(true, 500, height - 341, 95, 95, homeZ, azulEscuro); //(square?, x, y, w, h, icon, bgColor)

  // Draw the Button for the home XY
  xy_home = new Button(false, 250, 300, 100, 100, homeXY, azulEscuro);
  
  // Declare the PIP UART function
  

}

// -----------------------------------------------------------------------------
// The main draw function for 'PontosDispensa'
// -----------------------------------------------------------------------------
// Original function - No changes
public void desenhaTelaPontosDispensa() {
  background(branco);


  // 1) Draw the precision selector
  precisionSelector.draw();

  // 2) Coordinates text
  fill(azulEscuro);
  textSize(32);
  textAlign(CENTER, CENTER);
  text("X = " + coordenadas[0] + "  Y = " + coordenadas[1] + "  Z = " + coordenadas[2], 250, 123);

  // 3) Draw the direction pad shape
  shape(dirPad);

  // 3.1) Draw the directional labels (+-X, +-Y)
  fill(branco);
  textSize(20);
  textAlign(CENTER, CENTER);
  text("+X", 362, 300); // Original label position
  text("-X", 135, 300); // Original label position
  text("+Y", 247, 186); // Original label position
  text("-Y", 247, 414); // Original label position

  // 4) Draw the button home for axis x & y
  /* Original commented code - kept as is
  fill(azulEscuro);
  ellipse(250, 300, 100, 100);
  fill(branco);
  image(homeXY, 132, 235);*/
  xy_home.draw();

  // 5) Side panel for 'Pontos adicionados'
  fill(brancoBege);
  rect(width - 340, 70, 300, height - 280, 8);

  fill(azulEscuro);
  textSize(18);
  textAlign(LEFT, CENTER);
  text("Pontos de Dispensa", width - 310, 100);

  // 6) List of points
  drawPointsList();

  // Always show the scroll buttons
  scrollUpButton.draw();
  scrollDownButton.draw();

  // 7) Action buttons: add, edit, delete
  addButton.draw();
  editButton.draw();
  deleteButton.draw();

  // 8) Draw Lock XY / Lock Z buttons
  lockXYButton.draw();
  lockZButton.draw();

  // 9) Draw backButton
  backButton.draw(); 

  // 10) Draw Z buttons
  z_plus.draw();
  z_minus.draw();
  z_home.draw();

}

// -----------------------------------------------------------------------------
// Draw the list of points in side panel
// -----------------------------------------------------------------------------

public void drawPointsList() {
  int startY     = 150;
  int itemHeight = 40;

  fill(azulEscuro);
  textSize(12);
  textAlign(LEFT, CENTER);

  int endIndex = min(listaPontos.size(), scrollOffset + maxVisiblePoints);

  hasItemsAbove = scrollOffset > 0;
  hasItemsBelow = endIndex < listaPontos.size();

  // Simbolo "^"
  if (hasItemsAbove) {
    fill(azulEscuro);
    textSize(20);
    textAlign(CENTER, CENTER);
    text("^", width - 170, 130);
    textSize(12);
  }

  // Simbolo "v"
  if (hasItemsBelow) {
    fill(azulEscuro);
    textSize(15);
    textAlign(CENTER, CENTER);
    text("v", width - 170, startY + maxVisiblePoints * itemHeight);
    textSize(12);
  }

  for (int i = scrollOffset; i < endIndex; i++) {
    PontoDispensa ponto = listaPontos.get(i);
    int y = startY + (i - scrollOffset)*itemHeight;

    // "Efeito" de seleçaõ do ponto
    if (ponto.selected) {
      fill(cinzaClaro);
      rect(width - 330, y - 15, 225, 30, 5); // Original selection highlight size
    }

    // Checkbox
    fill(branco);
    stroke(azulEscuro);
    rect(width - 320, y - 10, 20, 20, 3);
    if (ponto.selected) {
      fill(azulEscuro);
      rect(width - 315, y - 5, 10, 10, 2);
    }

    // Text label and coordinates
    fill(azulEscuro);
    noStroke();
    textAlign(LEFT, CENTER);
    text(ponto.toString(), width - 290, y); // Displays name and volume
    text("( " + ponto.coords[0] + ", " + ponto.coords[1] + ", " + ponto.coords[2] + " )",
         width - 200, y); // Displays dispense coordinates
    // NOTE: Collection coordinates (ponto.coordsColeta) are NOT displayed here in the original code
  }
}

// -----------------------------------------------------------------------------
//                                MOUSE PRESSED
// -----------------------------------------------------------------------------

public void mousePressedTelaMovimentacaoManual() {
  // 1) Check if clicked on back button
  if (backButton != null && backButton.isMouseOver()) { // Added null check for safety
    backButton.isPressed = true;
    return;
  }

  // Check precision selector
  precisionSelector.mousePressed();

  // 2) Direction pad segments
  for (int i = 0; i < 4; i++) {
    if (segments[i] != null && segments[i].contains(mouseX, mouseY)) { // Added null check
      segments[i].setFill(cinzaMedio);
      return;
    }
  }

  // 3) Center circle (original logic based on distance)
  // Note: Original code didn't explicitly link center circle click to xy_home button state
  if (dist(mouseX, mouseY, 250, 300) < 50) { // Using radius from botao_direcional inner circle (80/2=40, slightly larger area 50)
     // Original code might have intended this click for the home button.
     // If xy_home is the center button, handle its press state:
     if (xy_home.isMouseOver()) { // Check if over the actual button bounds
         xy_home.isPressed = true;
     }
     return; // Return as in original logic if center area clicked
  }


  // 4) Lock buttons: if a lock button is touched, mark it as pressed.
  if (lockXYButton.isMouseOver()) {
    lockXYButton.isPressed = true;
    return;
  }
  if (lockZButton.isMouseOver()) {
    lockZButton.isPressed = true;
    return;
  }

  // 5) Scroll buttons
  if (scrollUpButton.isMouseOver()) {
    scrollUpButton.isPressed = true;
    return;
  }
  if (scrollDownButton.isMouseOver()) {
    scrollDownButton.isPressed = true;
    return;
  }

  // 6) Points list checkboxes
  int startY   = 150;
  int itemH    = 40;
  int endIndex = min(listaPontos.size(), scrollOffset + maxVisiblePoints);
  for (int i = scrollOffset; i < endIndex; i++) {
    int y = startY + (i - scrollOffset)*itemH;
    // Original checkbox click area
    if (mouseX >= width - 320 && mouseX <= width - 300 &&
        mouseY >= y - 10 && mouseY <= y + 10) {
      listaPontos.get(i).selected = !listaPontos.get(i).selected;
      return;
    }
  }

  // 7) Action buttons: add, edit, delete
  if (addButton.isMouseOver()) {
    addButton.isPressed = true;
    pontosDispensa++; // Original logic increments here
    return;
  }
  if (editButton.isMouseOver()) {
    editButton.isPressed = true;
    return;
  }
  if (deleteButton.isMouseOver()) {
    deleteButton.isPressed = true;
    return;
  }

  // 8) Button for the Z axis
  if (z_plus.isMouseOver()) {
    z_plus.isPressed = true;
   return;
  }
  if (z_minus.isMouseOver()){
     z_minus.isPressed = true;
    return;
  }
  if (z_home.isMouseOver()){
    z_home.isPressed = true;
   return;
  }

  // 9) Button home for X & Y axis
  // This might have been intended to be handled by step 3 (center circle)
  // Adding explicit check for the button object itself for clarity
  if (xy_home.isMouseOver()){
   xy_home.isPressed = true;
   return;
  }

}


// -----------------------------------------------------------------------------
//                                MOUSE RELEASED
// -----------------------------------------------------------------------------

public void mouseReleasedTelaMovimentacaoManual() {
  // 0) Handle precision selector
  int prevSelectedIndex = precisionSelector.selectedIndex;
  precisionSelector.mouseReleased();

  if (prevSelectedIndex != precisionSelector.selectedIndex) {
    movSpeed = Integer.parseInt(precisionLabels[precisionSelector.selectedIndex].replaceAll("[^0-9]", ""));
  }

  // 1) Directional pad: reset color and move if not locked
  for (int i = 0; i < 4; i++) {
    if (segments[i] != null) { 
        segments[i].setFill(azulEscuro); 
        if (segments[i].contains(mouseX, mouseY) && !xyLocked) { 
          switch (i) {
            case 0: // Up
              coordenadas[1] -= movSpeed;
              coordenadas[1] = constrain(coordenadas[1], minY, maxY); // Set the limits for the Y axis
              break;
            case 1: // Right (Original logic: -X)
              coordenadas[0] -= movSpeed;
              coordenadas[0] = constrain(coordenadas[0], minX, maxX); // Set the limits for the X axis
              break;
            case 2: // Down
              coordenadas[1] += movSpeed;
              coordenadas[1] = constrain(coordenadas[1], minY, maxY);
              break;
            case 3: // Left (Original logic: +X)
              coordenadas[0] += movSpeed;
              coordenadas[0] = constrain(coordenadas[0], minX, maxX);
              break;
          }
        }
    }
  }

  // 2) Lock XY / Z buttons: Toggle lock state if button was pressed.
  if (lockXYButton.isPressed) {

    xyLocked = !xyLocked;
    lockXYButton.isSelected = xyLocked;
    lockXYButton.isPressed = false;

  }
  if (lockZButton.isPressed) {

    zLocked = !zLocked;
    lockZButton.isSelected = zLocked;
    lockZButton.isPressed = false;

  }

  // 3) Scroll up/down
  if (scrollUpButton.isPressed) {
    if (scrollUpButton.isMouseOver() && scrollOffset > 0) { // Original condition
      scrollOffset--;
    }
    scrollUpButton.isPressed = false;
  }
  if (scrollDownButton.isPressed) {
    if (scrollDownButton.isMouseOver() &&
        scrollOffset < listaPontos.size() - maxVisiblePoints) { // Original condition
      scrollOffset++;
    }
    scrollDownButton.isPressed = false;
  }

  // 4) Action buttons: add, edit, delete
  if (addButton.isPressed) {
    if (addButton.isMouseOver()) { // Original condition
      addNewPoint();
      // Original code didn't adjust scroll offset after adding
    }
    addButton.isPressed = false;
    // Note: Original mousePressed incremented pontosDispensa immediately.
    // If addNewPoint fails or isn't called, this count could be wrong.
    // Keeping original logic for now. Consider updating pontosDispensa in addNewPoint.
  }
  if (editButton.isPressed) {
    if (editButton.isMouseOver()) { // Original condition
      editSelectedPoints();
    }
    editButton.isPressed = false;
  }
  if (deleteButton.isPressed) {
    if (deleteButton.isMouseOver()) { // Original condition
      deleteSelectedPoints();
      // Original code didn't adjust scroll offset after deleting here
      // but deleteSelectedPoints itself had some scroll logic
    }
    deleteButton.isPressed = false;
     // Note: Original mousePressed didn't handle pontosDispensa decrement here.
     // deleteSelectedPoints handles it.
  }

  // 5) Back Button
  if (backButton != null && backButton.isPressed){ // Added null check
    backButton.isPressed = false; // Reset state first

    // Original logic checks isMouseOver implicitly by not checking it
    // To match original exactly, assume release anywhere triggers if pressed:
    // if (backButton.isMouseOver()) { // This check was NOT in original logic implicitly
       telaPontosDispensa = false;
       telaPipetagem = true;
    // }
  }

  // 6) Button for Z axis
  if (z_plus.isPressed){
    z_plus.isPressed = false; // Reset state first
    // Original logic doesn't check isMouseOver on release
    if (!zLocked){
      coordenadas[2] += movSpeed;
      coordenadas[2] = constrain(coordenadas[2], minZ, maxZ); // Set the limits for the Z axis
    }
  }
  if (z_minus.isPressed) {
   z_minus.isPressed = false; // Reset state first
   // Original logic doesn't check isMouseOver on release
   if (!zLocked){
     coordenadas[2] -= movSpeed;
     coordenadas[2] = constrain(coordenadas[2], minZ, maxZ);
     }
  }
  if (z_home.isPressed){
   z_home.isPressed = false; // Reset state first
   // Original logic doesn't check isMouseOver on release
   if (!zLocked){
     coordenadas[2] = 0;
     //coordenadas[2] = constrain(coordenadas[2], minZ, maxZ); (Original comment)
   }
  }

  // 7) Button Home for X & Y axis
  if (xy_home.isPressed){
   xy_home.isPressed = false; // Reset state first
   // Original logic doesn't check isMouseOver on release
   if (!xyLocked){
    coordenadas[0] = 0;
    coordenadas[1] = 0;
   }
  }

}


// -----------------------------------------------------------------------------
// Adding, deleting, and editing points
// -----------------------------------------------------------------------------
public void addNewPoint() {
  int nextPointNum = listaPontos.size() + 1;
  // Original naming convention
  String pointName = "Ponto " + (nextPointNum < 10 ? "0" + nextPointNum : nextPointNum);

  // Using 0, 0, 0 as placeholders for the new collection coordinates.
  PontoDispensa pc = new PontoDispensa(pointName, 3, // Default volume 3ml
                                       coordenadas[0], coordenadas[1], coordenadas[2],
                                       0, 0, 0); // Placeholder xc, yc, zc

  listaPontos.add(pc);
  // Note: Consider moving pontosDispensa++ from mousePressed here for accuracy
}

// Original function - No changes
public void deleteSelectedPoints() {
  for (int i = listaPontos.size() - 1; i >= 0; i--) {
    if (listaPontos.get(i).selected) {
      listaPontos.remove(i);
      pontosDispensa--; // Original logic decrements here
    }
  }

  // Original re-numbering logic
  for (int i = 0; i < listaPontos.size(); i++) {
    String pointName = "Ponto " + ((i+1 < 10) ? ("0" + (i+1)) : (i+1));
    listaPontos.get(i).nome = pointName;
  }

  // Original scroll adjustment logic
  if (scrollOffset > 0 && listaPontos.size() <= maxVisiblePoints) {
    scrollOffset = 0;
  }
  else if (scrollOffset > 0 && scrollOffset >= listaPontos.size() - maxVisiblePoints) {
    scrollOffset = max(0, listaPontos.size() - maxVisiblePoints);
  }
}

// Original function - No changes
public void editSelectedPoints() {
  ArrayList<String> selectedPoints = new ArrayList<String>();
  for (PontoDispensa p : listaPontos) {
    if (p.selected) {
      selectedPoints.add(p.toString()); // Original logic adds string representation
    }
  }
  println("Editing points: " + selectedPoints); // Original output
  // Trocar para a tela de editar pontos (Original comment)
  // telaPontosDispensa = false;
  // telaEditarPontos = true;
}


// -----------------------------------------------------------------------------
// Generate the final list of lists: [[x1,y1,z1,qt1,x_coleta,y_coleta,z_coleta], ...]
// -----------------------------------------------------------------------------
public ArrayList<int[]> gerarListaFormatoFinal() {
  
  ArrayList<int[]> listaFinal = new ArrayList<int[]>();

  for (PontoDispensa ponto : listaPontos) {
    int[] item = new int[7]; // Create an array to hold the 7 values

    item[0] = ponto.coords[0];       // x1 (dispense)
    item[1] = ponto.coords[1];       // y1 (dispense)
    item[2] = ponto.coords[2];       // z1 (dispense)
    item[3] = ponto.volume;          // qt1
    item[4] = ponto.coordsColeta[0]; // x_coleta
    item[5] = ponto.coordsColeta[1]; // y_coleta
    item[6] = ponto.coordsColeta[2]; // z_coleta
   
   listaFinal.add(item);
   
  }
  
  
  return listaFinal;
}

public String gerarStringFormatoFinal() {
  // Get the data in the structured list format first
  ArrayList<int[]> dataList = gerarListaFormatoFinal();

  // Handle the case where the list is empty
  if (dataList.isEmpty()) {
    return "[]"; // Return empty brackets string
  }

  // Use StringBuilder for efficient string building
  StringBuilder sb = new StringBuilder();
  sb.append("["); // Start with the opening bracket

  // Loop through the list of int arrays
  for (int i = 0; i < dataList.size(); i++) {
    int[] item = dataList.get(i); // Get the current inner array

    // If it's not the first item, add a comma separator
    if (i > 0) {
      sb.append(",");
    }

    // Append the string representation of the inner array
    // java.util.Arrays.toString() creates format like "[1, 2, 3]"
    sb.append(java.util.Arrays.toString(item));
  }

  sb.append("]"); // Add the closing bracket

  return sb.toString(); // Return the final formatted string

}
Button botao_ref, botao_voltar_ref;

// dimensões dos botões 
float botaoX    = 390;
float botaoY1   = 250;
float botaoY2   = botaoY1 + 70;
  
public void setupReferenciar(){
  
  botao_ref = new Button(true, botaoX, botaoY1, 250, 50, "Referenciar", azulEscuro, branco); // (square?, x, y, w, h, label, bgColor, textcolor)
  botao_voltar_ref = new Button(true, botaoX, botaoY2, 250, 50, "Voltar", azulEscuro, branco);

}


public void desenhaTelaReferenciar() {
  background(branco);

  // Caixa central
  float caixaLarg = 600;
  float caixaAlt  = 400;
  float caixaX    = (width - 600)/2;
  float caixaY    = (height - 400)/2;

  fill(brancoBege);
  rect(caixaX, caixaY, caixaLarg, caixaAlt, 16);

  // Texto
  textSize(24);
  fill(azulEscuro);
  textAlign(CENTER, CENTER);
  text("Referencie antes de começar", caixaX + caixaLarg / 2, caixaY + 100);
  
  // Botões
  botao_ref.draw();
  botao_voltar_ref.draw();
}

// -----------------------------------------------------------------------------
//                         Mouse Pressed Referenciar                
// -----------------------------------------------------------------------------
public void mousePressedReferenciar() {

  // Botao "Referenciar"
  if (botao_ref.isMouseOver()) {
      botao_ref.isPressed = true;
      return;
      
      //telaReferenciar = false;
      //telaReferenciarI2C   = true;
    }
    // Botão "Voltar"
    else if (botao_voltar_ref.isMouseOver()) {
      botao_voltar_ref.isPressed = true;
    }
    
}

// -----------------------------------------------------------------------------
//                         Mouse Released Referenciar                
// -----------------------------------------------------------------------------
public void mouseReleasedReferenciar(){
 
  // Botao "Referenciar"
  if (botao_ref.isPressed){
   botao_ref.isPressed = false;
   
   setupRefI2C();
   telaReferenciar = false;
   telaReferenciarI2C   = true;
  }
  
  else if (botao_voltar_ref.isPressed){
   botao_voltar_ref.isPressed = false;
   
   telaReferenciar = false;
   telaInicio      = true;
   telaReferenciarI2C   = false;
  }
  
  
}
// -----------------------------------------------------------------------------
//  TELA CONFIRMAR REFERENCIAMENTO (I2C)
// -----------------------------------------------------------------------------

// UI elements
Button botao_continuar_ref;

public void setupRefI2C(){
 
  botao_continuar_ref = new Button(true, 337, 280, 350, 50, "Continuar com referenciamento", azulClaro, branco);
}

public void desenhaRefI2C() {
  background(branco);

  // Caixa de mensagem
  float caixaX    = (width - 800)/2;
  float caixaY    = (height - 200)/2 - 50;

  fill(brancoBege);
  rect(caixaX, caixaY, 800, 200, 16);

  // Texto central
  textSize(24);
  fill(azulEscuro);
  textAlign(CENTER, CENTER);
  text("Certifique-se de que nenhum\nobjeto possa colidir com a pipeta",
       caixaX + 800 / 2, 230);

  // Botão "Continuar com referenciamento"
  botao_continuar_ref.draw();

}

public void mousePressedRefI2C() {
  if (botao_continuar_ref.isMouseOver()) {
    botao_continuar_ref.isPressed = true;
  }
  
}

public void mouseReleasedRefI2C() {
  if (botao_continuar_ref.isPressed) {
   botao_continuar_ref.isPressed = false;
       
   setupTelaPipetagem();
   telaReferenciarI2C   = false;
   telaPipetagem = true;
  }
 
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "--full-screen", "--bgcolor=#2946FC", "--stop-color=#F20C0C", "telaInicio" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
